{"componentChunkName":"component---src-templates-blog-js","path":"/blog/react_hooks","result":{"data":{"markdownRemark":{"frontmatter":{"title":"React Hooks","description":"useEffect and useState, practically speaking","date":"2021-01-31"},"html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.08510638297872%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABVklEQVQoz21R30uDUBR2Uza9unvFXSmdrnQ4oQmNysqCIhPKhwXVXhZElAgREfTjoRq9RNBDrOf+3I6CA8fOyz3nu3znO+c7TGMakiQhIXsFAfLGvJDKODOFSZPSJRv41HawLAM0wySEyBleJmNCEMeawYF9dNa7eugcny/2+oBgIk9pHMcFQZAkCcuyUJaUQcq7eVy9G/tvk/79hzu8hhGQKCKEMMYwLZA9zxsMBrVaDZCCDH8CD5rd00t//Lv9+bf29AV5a/ewrWu23anX67quU0odx4miCMoyWRRVu+slzyC7/vLtv09WLm7JgmYarWXLYhgmDEPf903TjOO4rJzvLFQrVnQC+huvP514aGzuCRUGgf0IZhc1TRuNRmmauq7L83yJnIsjajnG1n7TaLd3QkU3AMFFQAtFUVRVhWTeqfLNweHMJ64Kio2iff6ZeQYjzBzvHzkyOdNPbD7WAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-hooks\"\n        title=\"react-hooks\"\n        src=\"/static/86d0193d8ca1123913275a666a0d7721/1d69c/react_hooks.png\"\n        srcset=\"/static/86d0193d8ca1123913275a666a0d7721/4dcb9/react_hooks.png 188w,\n/static/86d0193d8ca1123913275a666a0d7721/5ff7e/react_hooks.png 375w,\n/static/86d0193d8ca1123913275a666a0d7721/1d69c/react_hooks.png 750w,\n/static/86d0193d8ca1123913275a666a0d7721/78797/react_hooks.png 1125w,\n/static/86d0193d8ca1123913275a666a0d7721/aa440/react_hooks.png 1500w,\n/static/86d0193d8ca1123913275a666a0d7721/0bdcb/react_hooks.png 1579w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>I won't rehash the <a href=\"https://reactjs.org/docs/hooks-intro.html\">documentation's</a> contents on hooks, but simply give a couple of snippets that would be useful to someone who has to revisit React after some time away. (Ah, the plight of full-stack developers, too much context switching!)</p>\n<h2>useState</h2>\n<p><code>useState</code> lets you add state to function components. </p>\n<p><code>useState</code> returns an array with two elements, where the first element is the current state, and the second element is a function that updates this piece of state. <code>useState</code> takes in the desired initial state as an argument.</p>\n<p>The use of <code>useState</code> demonstrated, in the form of a trivial counter application:</p>\n<pre><code>import React, { useState } from \"react\";\n\nconst App = () => {\n    const [count, setCount] = useState(10)\n\n    return (\n        &#x3C;div className=\"App\">\n            &#x3C;button onClick={() => setCount(count - 1)}>-&#x3C;/button>\n            &#x3C;button onClick={() => setCount(count + 1)}>+&#x3C;/button>\n            &#x3C;p>{count}&#x3C;/p>\n        &#x3C;/div>\n    );\n}\n\nexport default App;\n</code></pre>\n<p>In the above example, a variable is passed into the setter function. However, you can also pass in a function. This would work similarly, additionally preventing race conditions:</p>\n<pre><code>import React, { useState } from \"react\";\n\nconst App = () => {\n    const [count, setCount] = useState(10)\n\n    return (\n        &#x3C;div className=\"App\">\n            // Prevents race conditions\n            &#x3C;button onClick={() => setCount(currentCount => currentCount - 1)}>\n                -\n            &#x3C;/button>\n            &#x3C;button onClick={() => setCount(currentCount => currentCount + 1)}>\n                +\n            &#x3C;/button>\n            &#x3C;p>{count}&#x3C;/p>\n        &#x3C;/div>\n    );\n}\n\nexport default App;\n</code></pre>\n<p>A more practical example of <code>useState</code> would be to maintain the state of a form within an application, as shown below.</p>\n<pre><code>import React, { useState } from \"react\";\n\nconst App = () => {\n    const [email, setEmail] = useState(\"\");\n    const [password, setPassword] = useState(\"\");\n\n    return (\n        &#x3C;div>\n        &#x3C;input\n            name=\"email\"\n            value={email}\n            onChange={e => setEmail(e.target.value)}\n        />\n        &#x3C;input\n            type=\"password\"\n            name=\"password\"\n            value={password}\n            onChange={e => setPassword(e.target.value)}\n        />\n        &#x3C;/div> \n    );\n}\n\nexport default App;\n</code></pre>\n<p>If you have many fields in your forms, you can encapsulate individual <code>useState</code> hooks in a custom hook.</p>\n<pre><code>import React, { useState } from \"react\";\n\n// custom hook\nconst useForm = (initialValues) => {\n    const [values, setValues] = useState(initialValues);\n\n    return [values, e => {\n        setValues({\n            ...values,\n            [e.target.name]: e.target.value\n        })\n    }]\n}\n\nconst App = () => {\n    const [values, handleChange] = useForm({ email: '', password: ''})\n\n    return (\n        &#x3C;div>\n        &#x3C;input\n            name=\"email\"\n            value={values.email}\n            onChange={handleChange}\n        />\n        &#x3C;input\n            type=\"password\"\n            name=\"password\"\n            value={values.password}\n            onChange={handleChange}\n        />\n        &#x3C;/div> \n    );\n}\n\nexport default App;\n</code></pre>\n<h2>useEffect</h2>\n<p>Generally, every time a component renders, <code>useEffect</code> gets ran.</p>\n<p>In the below example, <code>useState</code> updates the component state each time a keystroke is made into the input (loosely speaking), so as the component rerenders, <code>useEffect</code> logs some output to the console.</p>\n<pre><code>import React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [myInput, setMyInput] = useState('')\n\n  useEffect(() => {\n    console.log(\"Rendered from useEffect\")\n  });\n\n  return (\n    &#x3C;div>\n      &#x3C;input value={myInput} onChange={e => setMyInput(e.target.value)}/>\n    &#x3C;/div>\n  )\n}\n\nexport default App;\n</code></pre>\n<p>You can control when rerenders happen by adding to second argument to the <code>useEffect</code> hook, which  is an array (known as the dependency array). In the example below, <code>useEffect</code> is ran when <code>myInput</code> changes. </p>\n<p>Do note, React does a shallow comparison here, so if you pass an object into the array, it will refresh every single time.</p>\n<pre><code>import React, { useState, useEffect } from \"react\";\n\nconst App = () => {\n  const [myInput, setMyInput] = useState('');\n  const [mySecondInput, setMySecondInput] = useState('');\n\n  useEffect(() => {\n    console.log(\"Rendered from useEffect\")\n  }, [myInput]);\n\n  return (\n    &#x3C;div>\n      &#x3C;input value={myInput} onChange={e => setMyInput(e.target.value)}/>\n      &#x3C;input value={mySecondInput} onChange={e => setMySecondInput(e.target.value)}/>\n    &#x3C;/div>\n  )\n}\n\nexport default App;\n</code></pre>\n<p>If the dependency array is empty, <code>useEffect</code> only runs when the component first loads, making the hook work the way <code>componentDidMount</code> would work in a class-based component.</p>\n<p>Happy referencing, future self!</p>"}},"pageContext":{"slug":"react_hooks"}},"staticQueryHashes":["3159585216","3159585216","440568431"]}